// Test utility functions for Ollama Middleware test suites

/**
 * Test result formatting and validation utilities
 */
class TestHelpers {
  
  /**
   * Format test results with consistent styling
   */
  static formatTestResult(testName, passed, details = '') {
    const icon = passed ? '‚úÖ' : '‚ùå';
    const status = passed ? 'PASSED' : 'FAILED';
    console.log(`   ${icon} ${testName}: ${status}${details ? ` - ${details}` : ''}`);
    return passed;
  }

  /**
   * Create a test timer for performance measurements
   */
  static createTimer() {
    const startTime = Date.now();
    return {
      elapsed: () => Date.now() - startTime,
      stop: () => {
        const duration = Date.now() - startTime;
        return duration;
      }
    };
  }

  /**
   * Validate JSON structure against expected schema
   */
  static validateJSONStructure(json, expectedFields, options = {}) {
    const { allowMissing = false, strictTypes = false } = options;
    
    if (!json || typeof json !== 'object') {
      return { valid: false, errors: ['Input is not a valid object'] };
    }

    const errors = [];
    const missingFields = [];

    for (const field of expectedFields) {
      if (!(field in json)) {
        missingFields.push(field);
        if (!allowMissing) {
          errors.push(`Missing required field: ${field}`);
        }
      } else if (strictTypes && typeof json[field] === 'undefined') {
        errors.push(`Field ${field} is undefined`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      missingFields,
      presentFields: Object.keys(json),
      coverage: ((expectedFields.length - missingFields.length) / expectedFields.length) * 100
    };
  }

  /**
   * Check if a string is valid JSON
   */
  static isValidJSON(str) {
    try {
      JSON.parse(str);
      return { valid: true };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  /**
   * Generate test statistics summary
   */
  static generateTestStats(results) {
    const total = results.length;
    const passed = results.filter(r => r.passed).length;
    const failed = total - passed;
    const successRate = total > 0 ? (passed / total) * 100 : 0;

    return {
      total,
      passed,
      failed,
      successRate: Math.round(successRate),
      summary: `${passed}/${total} tests passed (${Math.round(successRate)}%)`
    };
  }

  /**
   * Create a mock character for testing
   */
  static createMockCharacter(overrides = {}) {
    const defaultCharacter = {
      Name: 'Test Character',
      Age: '25',
      Description: 'A character created for testing purposes',
      Personality: 'Reliable and consistent',
      Background: 'Generated by test utilities',
      Goals: 'Successfully complete all tests',
      Conflicts: 'None in test environment',
      Relationships: 'Works well with other test entities',
      Weaknesses: 'Only exists during testing',
      Motivation: 'Validate system functionality'
    };

    return { ...defaultCharacter, ...overrides };
  }

  /**
   * Create mock setting data
   */
  static createMockSetting(overrides = {}) {
    const defaultSetting = {
      Name: 'Test Environment',
      TimePeriod: 'Present day',
      Location: 'Controlled test space',
      Culture: 'Testing culture',
      Atmosphere: 'Professional and focused'
    };

    return { ...defaultSetting, ...overrides };
  }

  /**
   * Simulate network delay for testing
   */
  static async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Safe execution wrapper with error handling
   */
  static async safeExecute(fn, description = 'operation') {
    try {
      const result = await fn();
      return { success: true, result, error: null };
    } catch (error) {
      return { 
        success: false, 
        result: null, 
        error: error.message || 'Unknown error',
        description 
      };
    }
  }

  /**
   * Compare two objects for testing equality
   */
  static deepEqual(obj1, obj2, ignoreFields = []) {
    if (obj1 === obj2) return true;
    
    if (!obj1 || !obj2 || typeof obj1 !== 'object' || typeof obj2 !== 'object') {
      return false;
    }

    const keys1 = Object.keys(obj1).filter(key => !ignoreFields.includes(key));
    const keys2 = Object.keys(obj2).filter(key => !ignoreFields.includes(key));

    if (keys1.length !== keys2.length) return false;

    for (const key of keys1) {
      if (!keys2.includes(key)) return false;
      if (!this.deepEqual(obj1[key], obj2[key], ignoreFields)) return false;
    }

    return true;
  }

  /**
   * Generate test report header
   */
  static printTestHeader(suiteName, description = '') {
    console.log('='.repeat(60));
    console.log(`üß™ ${suiteName.toUpperCase()}`);
    if (description) {
      console.log(`üìù ${description}`);
    }
    console.log('='.repeat(60) + '\n');
  }

  /**
   * Generate test report footer with statistics
   */
  static printTestFooter(stats, additionalInfo = {}) {
    console.log('\n' + '='.repeat(60));
    console.log('üìä TEST RESULTS SUMMARY');
    console.log('='.repeat(60));
    console.log(`Total Tests: ${stats.total}`);
    console.log(`Passed: ${stats.passed}`);
    console.log(`Failed: ${stats.failed}`);
    console.log(`Success Rate: ${stats.successRate}%`);
    
    if (additionalInfo.performance) {
      console.log(`Performance: ${additionalInfo.performance}`);
    }
    
    if (additionalInfo.notes) {
      console.log(`Notes: ${additionalInfo.notes}`);
    }

    const overallStatus = stats.successRate >= 80 ? '‚úÖ EXCELLENT' : 
                         stats.successRate >= 60 ? '‚ö†Ô∏è ACCEPTABLE' : '‚ùå NEEDS IMPROVEMENT';
    console.log(`\nOverall Status: ${overallStatus}`);
    console.log('='.repeat(60));
  }

  /**
   * Log test progress with consistent formatting
   */
  static logProgress(message, level = 'info') {
    const timestamp = new Date().toISOString().substr(11, 8);
    const prefix = {
      'info': '‚ÑπÔ∏è',
      'success': '‚úÖ',
      'warning': '‚ö†Ô∏è',
      'error': '‚ùå',
      'debug': 'üîç'
    }[level] || '‚ÑπÔ∏è';
    
    console.log(`[${timestamp}] ${prefix} ${message}`);
  }

  /**
   * Validate that a service is properly imported and functional
   */
  static validateService(service, serviceName, requiredMethods = []) {
    const errors = [];
    
    if (!service) {
      errors.push(`${serviceName} is not imported or is undefined`);
      return { valid: false, errors };
    }

    if (typeof service !== 'object' && typeof service !== 'function') {
      errors.push(`${serviceName} is not a valid service object or class`);
      return { valid: false, errors };
    }

    for (const method of requiredMethods) {
      if (typeof service[method] !== 'function') {
        errors.push(`${serviceName} missing required method: ${method}`);
      }
    }

    return { valid: errors.length === 0, errors };
  }

  /**
   * Memory usage monitoring utility
   */
  static getMemoryUsage() {
    const usage = process.memoryUsage();
    return {
      rss: Math.round(usage.rss / 1024 / 1024),      // MB
      heapTotal: Math.round(usage.heapTotal / 1024 / 1024), // MB
      heapUsed: Math.round(usage.heapUsed / 1024 / 1024),   // MB
      external: Math.round(usage.external / 1024 / 1024),   // MB
      summary: `RSS: ${Math.round(usage.rss / 1024 / 1024)}MB, Heap: ${Math.round(usage.heapUsed / 1024 / 1024)}MB`
    };
  }

  /**
   * Generate random test data
   */
  static generateRandomString(length = 10) {
    return Math.random().toString(36).substring(2, 2 + length);
  }

  static generateRandomNumber(min = 1, max = 100) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
}

module.exports = TestHelpers;